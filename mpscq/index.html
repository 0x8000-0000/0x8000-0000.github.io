<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Signbit MPSCQ: Signbit Libraries</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Signbit MPSCQ
   &#160;<span id="projectnumber">0.5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Signbit Libraries </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md0"></a>
Statistics</h1>
<p>High-performance and numerically accurate online statistics, implemented in <a class="el" href="classsbit_1_1Stats.html">sbit::Stats</a>.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Multiple-Producer Single-Consumer Queue</h1>
<p>This library contains a lock-free multiple-producer single-consumer queue.</p>
<p>The core of the library is the <a class="el" href="classsbit_1_1mpscq_1_1Queue.html">sbit::mpscq::Queue</a> class, aided by the <a class="el" href="classsbit_1_1mpscq_1_1MessagePool.html">sbit::mpscq::MessagePool</a> implementation.</p>
<p>The key insight that allows this simple and efficient lock-free implementation is that pushing a single into a stack is easy using compare-and-swap, but popping a single element from a queue or a stack is quite difficult. However, if we consider the case of a single consumer, there is no reason to pick elements one by one, when we can atomically "steal" the entire contents of the stack, swapping it with an empty stack. Transforming the stack into a queue then only requires the reversing of the link order which can be done in linear time.</p>
<p>Having solved the enqueuing / dequeueing performance problem, the next bottleneck becomes the allocation and release of the messages passing through the queue. Most lock-free algorithms in the published literature just waive away the cost of allocation and releasing, or use complicated hazard lists to maintain the released block "for a while."</p>
<p>The second key insight for improving the performance is that releasing a block after its contents was "consumed" is very much similar to "enqueueing" it on a free list. So we can implement message pools that are "processors" of free blocks. They maintain an unsynchronized list of free blocks from which they perform the allocation operations (unsynchronized, because the pools themselves are the only execution contexts manipulating them), and a synchronized "recycling queue" where actual consumers can return the released blocks. Pools allocate from the unsynchronized list first, and when that is depleted, the contents of the synchronized list are moved in-bulk to the unsynchronized list. If both lists are depleted, then a pool has the option of blocking, allocating more objects directly, or borrowing from an upstream pool. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
